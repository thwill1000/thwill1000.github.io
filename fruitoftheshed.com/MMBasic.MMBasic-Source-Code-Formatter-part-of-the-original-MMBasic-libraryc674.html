

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html dir="ltr" xmlns="http://www.w3.org/1999/xhtml">

<!-- Mirrored from fruitoftheshed.com/MMBasic.MMBasic-Source-Code-Formatter-part-of-the-original-MMBasic-library.ashx?NS=MMBasic by HTTrack Website Copier/3.x [XR&CO'2014], Wed, 09 Feb 2022 12:51:09 GMT -->
<!-- Added by HTTrack --><meta http-equiv="content-type" content="text/html;charset=utf-8" /><!-- /Added by HTTrack -->
<head><meta http-equiv="Content-Type" content="text/html; charset=utf-8" /><meta http-equiv="X-UA-Compatible" content="IE=8" /><title>
	MMBasic Source Code Formatter - Fruit Of The Shed
</title><script type="text/javascript" src="JS/jquery-1.4.2.min.js"></script>
<script type="text/javascript" src="JS/Scripts.js"></script>
<script type="text/javascript" src="JS/SearchHighlight.js"></script>
<link rel="stylesheet" media="print" href="Themes/Default/Print_Styles.css" type="text/css" />
<link rel="stylesheet" media="screen" href="Themes/Default/Screen_Styles%20-%20Copy.css" type="text/css" />
<link rel="stylesheet" media="screen" href="Themes/Default/Screen_Styles.css" type="text/css" />
<link rel="stylesheet" href="Themes/Editor.css" type="text/css" />
<link rel="search" href="searchf7b1.xml?OpenSearch=1" type="application/opensearchdescription+xml" title="Fruit Of The Shed - Search" /><script src="Themes/Default/Scripts.js" type="text/javascript"></script>
<link rel="shortcut icon" href="Themes/Default/Icon.ico" type="image/x-icon" />
</head>
<body>
    <form name="aspnetForm" method="post" action="http://fruitoftheshed.com/Default.aspx?Page=MMBasic-Source-Code-Formatter-part-of-the-original-MMBasic-library&amp;NS=MMBasic" id="aspnetForm">
<div>
<input type="hidden" name="__VIEWSTATE" id="__VIEWSTATE" value="/wEPDwUJMTQ3NjA4MDI2D2QWAmYPZBYCAgEPZBYCAgkPZBYEAhsPDxYCHg1BbnRoZW1WaXNpYmxlaGRkAicPDxYCHgdWaXNpYmxlaGQWAmYPFgIeC18hSXRlbUNvdW50ZmRkL9X+pH8J+jB1IIJZx71WjgOrjyw=" />
</div>

<script type="text/javascript">
//<![CDATA[
var Anthem_FormID = "aspnetForm";
//]]>
</script>
<script src="WebResource3c0c.axd?d=wu8PDPV1hmKciPrhUAi9NEjQUBbOefrIXCaRPwGH8Q5jrvPZFuGbKmycL3GXDKGD1_JZ083oQl1Kpd_P7rg1V93MtYOS3Vb-0Eztmu5VDCWQxc7l0&amp;t=636158881040000000" type="text/javascript"></script>
<div>

	<input type="hidden" name="__VIEWSTATEGENERATOR" id="__VIEWSTATEGENERATOR" value="CA0B0334" />
</div>
		<script type="text/javascript">
<!--
__BaseName = "ctl00_CphMaster_";
__ConfirmMessage = "Are you sure you want to proceed?";
// -->
</script>
		<script type="text/javascript">
		<!--
			function __GetServerElementById(id) {
				return document.getElementById(__BaseName + id);
			}
			function __RequestConfirm() {
				return confirm(__ConfirmMessage);
			}
		// -->
		</script>
    
        <div id="HeaderDiv">
            <div style="float: right;">Welcome <a href="MMBasic.Language.html" class="systemlink" title="Select your language">Guest</a>, you are in: <select class="namespacedropdown" onchange="javascript:var sel = this.value; document.location = (sel != '' ? (sel + '.') : '') + 'Default.aspx';"><option value="">&lt;root&gt;</option><option value="Circuit Ideas">Circuit Ideas</option><option value="Colour MaxiMite 2 (CMM2)">Colour MaxiMite 2 (CMM2)</option><option value="GCB">GCB</option><option value="MicroMite ArmMite and MMX Hardware">MicroMite ArmMite and MMX Hardware</option><option selected="selected" value="MMBasic">MMBasic</option><option value="PIC ASM">PIC ASM</option><option value="Platform Agnostic">Platform Agnostic</option></select> &bull; <a href="MMBasic.Login8968.html?Redirect=http%3a%2f%2ffruitoftheshed.com%2fDefault.aspx%3fPage%3dMMBasic-Source-Code-Formatter-part-of-the-original-MMBasic-library%26NS%3dMMBasic" class="systemlink" title="Login">Login</a></div><h1>Fruit Of The Shed</h1>
        </div>
                   
        <div id="ContainerDiv">
                 
            <div id="SidebarDiv">
                <div id="SidebarHeaderDiv">
                    <!-- Used for layout purposes only -->
                </div>
                <div id="SidebarContentDiv">
                    <div style="float: right;"> </div><h3 class="separator">Navigation (MMBasic)<a class="headeranchor" id="Navigation_NAMESPACE_0" href="#Navigation_NAMESPACE_0" title="Link to this Section">&#0182;</a></h3><ul><li><b><a class="pagelink" href="MMBasic.MainPage.html" title="_MMBasic Code Library">Main Page</a></b></li><li><a class="pagelink" href="MainPage.html" title="Home Page">Main Page (root)</a><br /></li></ul><br /><ul><li><a class="systemlink" href="MMBasic.EggDrop-part-of-the-original-MMBasic-libraryc674.html" title="Random Page">Random Page</a></li><li><a class="systemlink" href="MMBasic.AllPages.html" title="All Pages">All Pages</a><br /> </li><li><a class="systemlink" href="Logina75d.html" title="Create a new Page">Create a new Page</a><br /></li></ul><br /><ul><li><a class="systemlink" href="Logine894.html" title="Administration">Administration</a></li><li><a class="systemlink" href="MMBasic.Upload.html" title="File Management">File Management</a><br /></li></ul><br /><ul><li><a class="systemlink" href="MMBasic.Register.html" title="My Account">My Account</a><br /></li></ul><br /><ul><li><a class="systemlink" href="MMBasic.Register.html" title="Create Account">Create Account</a><br /></li></ul><br /><small><b>Search the wiki</b></small><br /><br /><script type="text/javascript"><!--
function _DoSearch_SBf63524b4df3e46d58daced6fab3b588b() { document.location = 'MMBasic.Search.aspx?AllNamespaces=1&FilesAndAttachments=1&Query=' + encodeURI(document.getElementById('SBf63524b4df3e46d58daced6fab3b588b').value); }
// -->
</script><input class="txtsearchbox" type="text" id="SBf63524b4df3e46d58daced6fab3b588b" onkeydown="javascript:var keycode; if(window.event) keycode = event.keyCode; else keycode = event.which; if(keycode == 10 || keycode == 13) { _DoSearch_SBf63524b4df3e46d58daced6fab3b588b(); return false; }" /> <big><a href="#" onclick="javascript:_DoSearch_SBf63524b4df3e46d58daced6fab3b588b(); return false;">&raquo;</a></big><br /><br /><br />
                </div>
                <div id="SidebarFooterDiv">
                    <!-- Used for layout purposes only -->
                </div>
            </div>
            <div id="MainDiv">
                <div id="MainHeaderDiv">
                    <!-- Used for layout purposes only -->
                </div>
                <div id="PageInternalHeaderDiv"></div>
                

    <script type="text/javascript">
    <!--
        function __ShowAllTrail() {
            try {
                document.getElementById("BreadcrumbsDivMin").style["display"] = "none";
                document.getElementById("BreadcrumbsDivAll").style["display"] = "";
                __SetStatus("1");
            }
            catch(ex) { }
            return false;
        }
        function __HideTrail() {
            try {
                document.getElementById("BreadcrumbsDivMin").style["display"] = "";
                document.getElementById("BreadcrumbsDivAll").style["display"] = "none";
                __SetStatus("0");
            }
            catch(ex) { }
            return false;
        }
        
        function __SetStatus(open) {
            __CreateCookie("ScrewTurnWikiBCT", open, 365);
        }
        function __GetStatus() {
            var value = __ReadCookie("ScrewTurnWikiBCT");
            if(value) return value;
            else return "0";
        }

        function __InitBCT() {
        	if(__GetStatus() == "1") {
        		__ShowAllTrail();
        	}
        }

        var __attachmentsMenuJustShown = false;
        var __adminToolsMenuJustShown = false;
        var __ie7Mode = false;

        function __ToggleAttachmentsMenu(cx, cy) {
        	var element = document.getElementById("PageAttachmentsDiv");
        	if(element) {
        		if(element.style["display"] == "none") {
        			element.style["display"] = "";
        			var pos = __AbsolutePosition(element);
        			if(pos.left - cx > 0) {
        				__ie7Mode = true;
        				element.style["position"] = "absolute";
        				element.style["top"] = cy + "px";
        				element.style["left"] = (cx - pos.width) + "px";
        			}
        			else {
        				__RepositionDiv(document.getElementById("PageAttachmentsLink"), element);
        			}
        			__attachmentsMenuJustShown = true;
        		}
        	}
        	return false;
        }
        function __HideAttachmentsMenu() {
        	var element = document.getElementById("PageAttachmentsDiv");
        	if(element && !__attachmentsMenuJustShown) {
        		element.style["display"] = "none";
        		if (__ie7Mode) element.style["left"] = "10000px";
        	}
        	__attachmentsMenuJustShown = false;
        	return true; // Needed to enabled next clicks' action (file download)
        }

        function __ToggleAdminToolsMenu(cx, cy) {
        	var element = document.getElementById("AdminToolsDiv");
        	if(element) {
        		if(element.style["display"] == "none") {
        			element.style["display"] = "";
        			var pos = __AbsolutePosition(element);
        			if(pos.left - cx > 0) {
        				__ie7Mode = true;
        				element.style["position"] = "absolute";
        				element.style["top"] = cy + "px";
        				element.style["left"] = (cx - pos.width) + "px";
        			}
        			else {
        				__RepositionDiv(document.getElementById("AdminToolsLink"), element);
        			}
        			__adminToolsMenuJustShown = true;
        		}
        	}
        	return false;
        }
        function __HideAdminToolsMenu() {
        	var element = document.getElementById("AdminToolsDiv");
        	if(element && !__adminToolsMenuJustShown) {
        		element.style["display"] = "none";
        		if(__ie7Mode) element.style["left"] = "10000px";
        	}
        	__adminToolsMenuJustShown = false;
        	return true; // Needed to enable next clicks' action (admin tools)
        }

        function __HideAllMenus() {
        	__HideAttachmentsMenu();
        	__HideAdminToolsMenu();
        }

        document.body.onclick = __HideAllMenus;

        function __AbsolutePosition(obj) {
        	var pos = null;
        	if(obj != null) {
        		pos = new Object();
        		pos.top = obj.offsetTop;
        		pos.left = obj.offsetLeft;
        		pos.width = obj.offsetWidth;
        		pos.height = obj.offsetHeight;

        		obj = obj.offsetParent;
        		while(obj != null) {
        			pos.top += obj.offsetTop;
        			pos.left += obj.offsetLeft;
        			obj = obj.offsetParent;
        		}
        	}
        	return pos;
        }

        var __showTimer = null;
        var __hideTimer = null;

        function __ShowDropDown(e, divId, parent) {
           	// Set a timer
        	// On mouse out, cancel the timer and start a 2nd timer that hides the menu
        	// When the 1st timer elapses
        	//   show the drop-down
        	//   on menu mouseover, cancel the 2nd timer
        	//   on menu mouse out, hide the menu
        	__showTimer = setTimeout('__ShowDropDownForReal(' + e.clientX + ', ' + e.clientY + ', "' + divId + '", "' + parent.id + '");', 200);
        }

        function __ShowDropDownForReal(cx, cy, divId, parentId) {
        	var pos = __AbsolutePosition(document.getElementById(parentId));
        	var menu = document.getElementById(divId);

			// This is needed to trick IE7 which, for some reason,
			// does not position the drop-down correctly with the new Default theme
        	if(pos.left - cx > 30) {
        		menu.style["display"] = "";
        		menu.style["position"] = "absolute";
        		menu.style["top"] = cy + "px";
        		menu.style["left"] = (cx - 10) + "px";
        	}
        	else {
        		menu.style["display"] = "";
        		menu.style["position"] = "absolute";
        		menu.style["top"] = (pos.top + pos.height) + "px";
        		menu.style["left"] = pos.left + "px";
        	}
        	__showTimer = null;
        }

        function __HideDropDown(divId) {
        	if(__showTimer) clearTimeout(__showTimer);
        	__hideTimer = setTimeout('__HideDropDownForReal("' + divId + '");', 200);
        }

        function __HideDropDownForReal(divId) {
        	document.getElementById(divId).style["display"] = "none";
        	__hideTimer = null;
        }

        function __CancelHideTimer() {
        	if(__hideTimer) clearTimeout(__hideTimer);
        }
        
    // -->
    </script>

	<a id="PageTop"></a>
	
	<div id="PageHeaderDiv">
	
		<!-- Change this to PageToolbarDiv -->
		<div id="EditHistoryLinkDiv">
			<a id="DiscussLink" title="Discuss" href="MMBasic.MMBasic-Source-Code-Formatter-part-of-the-original-MMBasic-library266d.html?Discuss=1">Discuss (0)</a>
			
			
			<a id="HistoryLink" title="View Page edit history" href="MMBasic.History09bb.html?Page=MMBasic.MMBasic-Source-Code-Formatter-part-of-the-original-MMBasic-library">History</a>
			
			
			
			
			
		</div>
		
		<h1 class="pagetitle">
			
			MMBasic Source Code Formatter
			
		</h1>
		
		<div id="PrintLinkDiv">
			<a id="PrintLink" href="MMBasic.Print09bb.html?Page=MMBasic.MMBasic-Source-Code-Formatter-part-of-the-original-MMBasic-library" title="Printer friendly version" target="_blank">Print</a>
		</div>
		
		<div id="RssLinkDiv">
			
		</div>
		
		<div id="EmailNotificationDiv">
			<span id="Anthem_ctl00_CphMaster_btnEmailNotification__"></span>
		</div>
		
		<div id="ctl00_CphMaster_pnlPageInfo">
	
			<div id="PageInfoDiv">
				<span id="ModificationSpan">
					Modified on 
					2016/12/23 23:35
				</span>
				<span id="AuthorSpan">
					 by 
					<a href="MMBasic.User6a4a.html?Username=admin">Administrator</a>
				</span>
				<span id="NavPathsSpan">
					
				</span>
				<span id="CategoriesSpan">
					Categorized as 
					<a href="MMBasic.AllPages0409.html?Cat=MMBasic.Program%20Management" title="Program Management">Program Management</a>, <a href="MMBasic.AllPages0f85.html?Cat=MMBasic._LIB%20Original%20MMBasic" title="_LIB Original MMBasic">_LIB Original MMBasic</a>
				</span>
				
				<span id="PageDiscussionSpan">
					
					
				</span>
			</div>
		
</div>
		
		<div id="fc7e6f651-9213-4d95-b90e-b217b618bcaa" style="display: none;" class="pageoutgoinglinksmenu" onmouseover="javascript:return __CancelHideTimer();" onmouseout="javascript:return __HideDropDown('fc7e6f651-9213-4d95-b90e-b217b618bcaa');"><a href="MMBasic.Ultra-Compact-Logging-with-Flash-Storage-on-small-MicroMites.html" title="Ultra-Compact Logging with Flash Storage on small MicroMites">Ultra-Compact Logging with Flash Storage on small MicroMites</a></div><div id="faa842da9-8c65-467f-9353-a98ad0883de2" style="display: none;" class="pageoutgoinglinksmenu" onmouseover="javascript:return __CancelHideTimer();" onmouseout="javascript:return __HideDropDown('faa842da9-8c65-467f-9353-a98ad0883de2');"></div><div id="s5c4d598b-cbde-4173-861e-e3c4c19f23eb" style="display: none;" class="pageoutgoinglinksmenu" onmouseover="javascript:return __CancelHideTimer();" onmouseout="javascript:return __HideDropDown('s5c4d598b-cbde-4173-861e-e3c4c19f23eb');"><a href="MMBasic.Ultra-Compact-Logging-with-Flash-Storage-on-small-MicroMites.html" title="Ultra-Compact Logging with Flash Storage on small MicroMites">Ultra-Compact Logging with Flash Storage on small MicroMites</a></div><div id="BreadcrumbsDiv"><div id="BreadcrumbsDivMin"><a href="#" onclick="javascript:return __ShowAllTrail();" title="Click here to view the complete Breadcrumbs Trail">(10)</a> &raquo; <a href="MMBasic.MMBasic-Create-Manipulate-Stack-Queue-or-List.html" title="MMBasic - Create/Manipulate Stack, Queue or List (MMBasic)">MMBasic - Create/Manipulate Stack, Queue or List (MMBasic)</a> &raquo; <a href="MMBasic.MMBasic-code-pack-to-Read-and-Write-Winbond-Flash-Memories.html" title="MMBasic code-pack to Read and Write Winbond Flash Memories (MMBasic)" onmouseover="javascript:return __ShowDropDown(event, 's5c4d598b-cbde-4173-861e-e3c4c19f23eb', this);" id="lnks5c4d598b-cbde-4173-861e-e3c4c19f23eb" onmouseout="javascript:return __HideDropDown('s5c4d598b-cbde-4173-861e-e3c4c19f23eb');">MMBasic code-pack to Read and Write Winbond Flash Memories (MMBasic)</a> &raquo; <b><a href="MMBasic.MMBasic-Source-Code-Formatter-part-of-the-original-MMBasic-library.html" title="MMBasic Source Code Formatter (MMBasic)">MMBasic Source Code Formatter (MMBasic)</a></b> </div><div id="BreadcrumbsDivAll" style="display: none;"><a href="#" onclick="javascript:return __HideTrail();" title="Click here to hide the Breadcrumbs Trail">[X]</a> &raquo; <a href="MMBasic.MaxiTrek-part-of-the-original-MMBasic-library.html" title="MaxiTrek (MMBasic)">MaxiTrek (MMBasic)</a> &raquo; <a href="MMBasic.MaxMan-part-of-the-original-MMBasic-library.html" title="MaxMan (MMBasic)">MaxMan (MMBasic)</a> &raquo; <a href="MMBasic.Maze-bas-part-of-the-original-MMBasic-library.html" title="Maze.bas (MMBasic)">Maze.bas (MMBasic)</a> &raquo; <a href="MMBasic.Measuring-RMS-algorythm-using-MMBasic.html" title="Measuring RMS (algorythm) using MMBasic (MMBasic)">Measuring RMS (algorythm) using MMBasic (MMBasic)</a> &raquo; <a href="MMBasic.Micromite-eXtreme-Manual.html" title="Micromite eXtreme 5.4.05 Manual and Firmware (MMBasic)">Micromite eXtreme 5.4.05 Manual and Firmware (MMBasic)</a> &raquo; <a href="MMBasic.Midd-Function-to-replace-a-section-of-a-string-works-like-VB-statement-Mid.html" title="Midd$ Function to replace a section of a string, works like VB statement Mid$()= (MMBasic)">Midd$ Function to replace a section of a string, works like VB statement Mid$()= (MMBasic)</a> &raquo; <a href="MMBasic.MM-Event-part-of-the-original-MMBasic-library.html" title="MM_Event (MMBasic)">MM_Event (MMBasic)</a> &raquo; <a href="MMBasic.MMBasic-Create-Manipulate-Stack-Queue-or-List.html" title="MMBasic - Create/Manipulate Stack, Queue or List (MMBasic)">MMBasic - Create/Manipulate Stack, Queue or List (MMBasic)</a> &raquo; <a href="MMBasic.MMBasic-code-pack-to-Read-and-Write-Winbond-Flash-Memories.html" title="MMBasic code-pack to Read and Write Winbond Flash Memories (MMBasic)" onmouseover="javascript:return __ShowDropDown(event, 'fc7e6f651-9213-4d95-b90e-b217b618bcaa', this);" id="lnkfc7e6f651-9213-4d95-b90e-b217b618bcaa" onmouseout="javascript:return __HideDropDown('fc7e6f651-9213-4d95-b90e-b217b618bcaa');">MMBasic code-pack to Read and Write Winbond Flash Memories (MMBasic)</a> &raquo; <b><a href="MMBasic.MMBasic-Source-Code-Formatter-part-of-the-original-MMBasic-library.html" title="MMBasic Source Code Formatter (MMBasic)">MMBasic Source Code Formatter (MMBasic)</a></b> </div></div>
		
		
	
	</div>
	
	<div id="PageContentDiv">
		<h2 class="separator">This module is part of the original MMBasic library. It is reproduced here with kind permission of Hugh Buckle and Geoff Graham. Be aware it may reference functionality which has changed or is deprecated in the latest versions of MMBasic.<a class="headeranchor" id="This_module_is_part_of_the_original_MMBasic_library_It_is_reproduced_here_with_kind_permission_of_Hugh_Buckle_and_Geoff_Graham_Be_aware_it_may_reference_functionality_which_has_changed_or_is_deprecated_in_the_latest_versions_of_MMBasic_0" href="#This_module_is_part_of_the_original_MMBasic_library_It_is_reproduced_here_with_kind_permission_of_Hugh_Buckle_and_Geoff_Graham_Be_aware_it_may_reference_functionality_which_has_changed_or_is_deprecated_in_the_latest_versions_of_MMBasic_0" title="Link to this Section">&#0182;</a></h2><b>Note</b>: Any required file(s) are available in the attachments tab (top right).<br /><br /><br /><u>MMBasic Source Formatter ver 2.3 20/4/2013</u><br /><br /><br />Format.bas is a program to indent lines of MMBasic source code in order to highlight the program structure.<br /><br /><br /><u>Four methods to invoke</u>:<br /><br /><br /><b>1. Implied Run Command</b><br />MMBasic ver 4.3A allows you to invoke a program from the prompt with the program name followed by a parameter list. The parameter list is passed to the program in the Read-Only Variable MM.CMDLINE$.<br /><br />At the MMBasic prompt type:<br /><br />	FORMAT InFileName&#0091;.bas&#0093; OutFileName&#0091;.bas&#0093; &#0091;Indent&#0093; &#0091;/P&#0093;<br /><br />Where:<br />	InFileName  is the program source to be formatted.<br />	OutFileName is the result of formatting.<br />		    OutFileName must not be the same as InfileName.<br />	Indent      is the optional number of characters to indent at each level (default 2)<br />	/P          is an optional switch to list the output, pausing each screenful<br /><br />	If an extension is not provided on the file names, Format inserts .bas.<br /><br />If you prefer, you can separate parms with either a blank or a comma so this is also valid:<br /><br />	FORMAT InFileName&#0091;.bas&#0093;,OutFileName&#0091;.bas&#0093;,&#0091;Indent&#0093;,&#0091;/P&#0093;<br /><br /><br /><b>2. Chaining from another program</b><br />If you Chain to Format, you can either<br />  - create a file FORMAT.DAT containing the parameters (see method 3 below) or <br />  - let Format prompt for all four parameters as if you had just used method 4 below or <br />  - you can pass the 4 parameters to it in a variable CMDParm$. <br /><br />To use the latter, transfer control to Format using:<br /><br />	CMDParm$ = "InFileName&#0091;.bas&#0093; OutFileName&#0091;.bas&#0093; &#0091;Indent&#0093; &#0091;/p&#0093;"<br />	CHAIN "FORMAT.BAS"<br /><br />Format uses about 55kB of memory, so if your Chaining program uses large arrays, you may need to ERASE them before chaining to Format.<br /><br /><br /><b>3. Config file FORMAT.DAT</b><br />If Format doesn't find the parameter list in MM.CMDLINE$ or CMDParm$, then it looks for a file FORMAT.DAT. This file contains a single line in the same format as the parameter list for the Implied RUN Command. i.e.<br /><br />	InFileName&#0091;.bas&#0093; OutFileName&#0091;.bas&#0093; &#0091;Indent&#0093; &#0091;/P&#0093; or<br />	InFileName&#0091;.bas&#0093;,OutFileName&#0091;.bas&#0093;,&#0091;Indent&#0093;,&#0091;/P&#0093;<br /><br /><br /><b>4. "Normal" invocation</b><br />You can invoke Format by typing RUN "FORMAT&#0091;.BAS&#0093;" at the command prompt and Format will prompt for the four parameters.<br /><br />FORMAT's standard set of rules:<br /><br />	- Lines starting with a Label are aligned to the left margin<br />	  as are SUB, END SUB, FUNCTION and END FUNCTION.<br /><br />	- The first non-label line is indented to the first level.<br /><br />	- Lines following a single line IF, DO and FOR are not further indented.<br /><br />	- Multiline DO and FOR have their respective LOOP and NEXT aligned.<br />	  Intervening lines are indented one level.<br /><br />	- The NEXT that closes multiple levels of FOR is aligned under the first FOR.<br /><br />	- Multiline IF statements have their ELSE, ELSEIF and ENDIF aligned<br />	  under the relevant IF. Intervening statements are indented one level.<br /><br />	- Nesting increases the indent one level.<br /><br />	- For numbered programs, the line number is left aligned and the rest of the source<br />	  uses the length of the longest number plus one as the left margin.<br /><br />	- Other than setting the indent, the source line is not altered.<br /><br />	- No attempt is made to check or report program errors.<br /><br /><br /><b>Implementaion Details</b><br />Initialisation gets input and output file names, indent and pause. The input file is checked to make sure it exists and if the output exists, the user is asked to confirm that it be used. The program doesn't allow the output to overwrite the input in case of a power or equipment failure.<br /><br />The program first runs through the input file looking for line numbers, storing the length of the longest line number. If found, the line numbers are aligned at the left margin and the margin for the rest of the code set at the longest line number plus one space..<br /><br />Each line is read in turn and, working on a copy of the line, the indent of the current and next line is found. The original line is then stripped of any leading spaces, indented with an appropriate number of blanks and written out. If the Pause switch has been set, the program copies the formatted source to the screen, pausing at each screenful for the user to press a key.<br /><br />Each line is examined and processed in turn, writing it out when completed.<br /><br />The first text encountered on the line is tested to see if it is, in order of precedence:<br /><br />- A comment or end-of-line.<br />- SUB, END SUB, FUNCTION, END FUNCTION<br />- DO<br />- LOOP<br />- FOR<br />- NEXT<br />- IF... THEN<br />- ELSEIF<br />- ELSE<br />- Label<br /><br />Appropriate indenting action is taken if one of these commands is found at the start of a line. The line is then searched for colons and indenting adjusted if another of these commands is found.<br /><br />Lines starting with SUB, END SUB, FUNCTION, END FUNCTION or a label are aligned to the left margin.<br /><br />Lines starting with DO, FOR and IF signal that the following line should be indented one level.<br /><br />Lines starting with LOOP, NEXT, ELSEIF and ELSE are set to one less level of indent than the previous line. If the NEXT is followed by multiple loop variables, then an indent is removed for each variable.<br /><br />If a LOOP or NEXT appears on the same line as it's DO and FOR, then the level change for the next line is cancelled.<br /><br />If an IF... THEN is followed by a statement (and optional ELSE), then it is treated as a single-line-if and the level change for the next line cancelled.<br /><br /><br /><b>Tables</b><br />Two tables, populated by DATA statements, are used to help parse a line:<br /><br />- One contains reserved words which can be followed immediately by a colon. e.g. PRINT: This is used to prevent these words from being incorrectly identified as a label.<br /><br />- The other table contains a list of operators which is used to differenitate between a label and any other statement. Contiguous text containing an operator cannot be a label. e.g. A=B: is not a label.<br /><br /><br /><b>Change Log</b><br />20/4/2013 V2.3<br />- When a file has line numbers followed by one or more spaces and a colon, the colon is moved adjacent to the line number. This mod was triggerd by MMPREY.BAS in MMLib which exhibits this condition.<br />- If a line starts with a colon (after the optional line number and its optional colon) then it is removed.<br />- e.g. "1234   : Statement"   is changed to <br />       "1234: Statement". <br /><br />       "1234:  :Statement"   is changed to <br />       "1234: Statement".<br /> <br />       "   :Statement :Statement" is changed to<br />       "   Statement :Statement"<br />- Fixed a problem when nested FOR/NEXT loops appear on a single line and one of the NEXT statements terminates more than one level.<br /><br />Hugh Buckle<br /><br /><b>FORMAT.BAS</b>:<br /><pre>
  ' MMBasic Program Source Formatter v2.3
  ' Hugh Buckle  March 2013 - updated April 2013
  
  '&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;
  ' You can run this version from the prompt using the Implied RUN Command
  '
  '   FORMAT InFileName&#91;.BAS&#93; OutFileName&#91;.BAS&#93; &#91;Indent&#93; &#91;/p&#93;
  '
  ' You can use either a comma or space between parameters
  '
  '   Where&#58; OutFileName must not be the same as InFileName
  '          Indent will default to 2 characters.
  '          /p lists the result to the screen - press a key to continue.
  '   You will be prompted if&#58;
  '          The input file doesn't exist
  '          The output file exists or is the same as the input file
  '          Indent is outside the range 1 to 6.
  '
  ' You can also run the program in the normal way using the RUN command
  ' in which case you will be prompted for file names, indent and pause.
  
  ' FORMAT's standard set of rules&#58;
  ' - Lines starting with a Label are aligned to the left margin
  '   as are SUB, END SUB, FUNCTION and END FUNCTION.
  ' - The first non-label line is indented to the first level.
  ' - Lines following a single line IF, DO and FOR are not further indented.
  ' - Multiline DO and FOR have their respective LOOP and NEXT aligned.
  '   Intervening lines are indented one level.
  ' - The NEXT that closes multiple levels of FOR is aligned
  '   under the first FOR.
  ' - Multiline IF statements have their ELSE, ELSEIF and ENDIF aligned
  '   under the relevant IF. Intervening statements are indented one level.
  ' - Nesting increases the indent one level.
  ' - For numbered programs, the left margin is the longest number plus one.
  ' - Other than setting the indent, the source line is not altered. However,
  '   if the line starts with a colon (after the line number and its optional
  '   colon), then it is removed.
  ' - No attempt is made to check the program for errors.
  '&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;
  
  true=1
  false=0
  Restore 'JD Addition
  
  CMDParmFile$ = "Format.dat"  'File of command line parms in format
  'InFileName&#91;.bas&#93; OutFileName&#91;.bas&#93; &#91;Indent&#93; &#91;/P&#93;
  
  ' Data contains operators, used to differentiate
  ' between a label and any other statement.
  Data "=","+","-","&#42;","/","&lt;","&gt;","\","^"
  Operators=9
  Dim Operator$(Operators)
  For I=1 To Operators
    Read Operator$(i)
  Next
  
  ' Data contains MMBasic commands which could be interpreted as labels
  Data "PRINT","RETURN","CLS","RESTORE","CLEAR","EXIT","FILES","MEMORY","NEW"
  Data "KEYDOWN","TROFF","TRON","DO","LOOP","NEXT"
  Commands=15
  Dim Command$(Commands)
  For i=1 To Commands
    Read Command$(i)
  Next
  
Mainline&#58;
  '&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;
  ' Initialisation gets input and output file names, indent and pause.
  ' Each line is read in turn and, working on a copy of the line,
  ' the indent of the current and next line is found. The original line
  ' is indented with an appropriate number of blanks and written out.
  ' If the first line contains a line number then the program skips through
  ' to the last line to find the maximum sized line number. Lines are then
  ' processed as before, adding a padded line number and indent to the code.
  '&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;
  
  initialise(Ifile$, Ofile$, Indent)
  Print
  Print "Formatting ";ifile$;" and writing to ";Ofile$
  Print String$(78,"_")
  CheckForLineNumbers
  
  CLI = Indent                      'Current line indent
  NLI = Indent                      'Next line indent
  
  Do While Not Eof(&#35;1)
    CLI = NLI
    Line Input &#35;1, iline$              ' Get next line
    oline$ = StripBlanks$(iline$)      ' Strip off leading blanks
    If LineNumbers Then ExtractLineNo  ' Remove the line number
    cline$ = oline$                    ' Make working copy
    AdjustIndent                       ' Find current &amp; next line indents
    oline$ = Space$(CLI) + Oline$      ' Indent current line
    If LineNumbers Then Oline$ = LineNo$ + Oline$
    Print &#35;2, oline$                   ' Write to output file
    If PauseList$="Y" Then
      Print oline$                     ' Print a copy to screen
      wait                             ' Pause at a screenful
    Else
      Print ".";
    EndIf
  Loop
  Close &#35;1
  Close &#35;2
  Print
  Print String$(78,"_")
  Print "Formatting finished. Please test the output file."
  If MasterFile$ &lt;&gt; "" Then 'JD Addition
    UpTo = UpTo + 1
    Chain MasterFile$
  EndIf
  End 'Mainline
  
Function StripBlanks$(A$)
  '&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;
  ' Strips blanks, tabs and colons from the beginning of the line.
  '&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;
  Local i
  i=1
  Do While Mid$(A$,i,1)=" " Or Mid$(A$,i,1)=Chr$(9) Or Mid$(A$,i,1)="&#58;"
    i=i+1
  Loop
  StripBlanks$ = Mid$(A$,i)  ' Copies from i to end of a$ to the function
End Function 'StripBlanks
  
Function Variable(a$,s)
  '&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;
  ' Checks the character after a command name to see if it's a variable.
  ' s points to the character after the command name
  '&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;
  Variable=True
  b$=Mid$(a$,s,1)
  If Len(a$)&lt;s Or b$=" " Or b$="&#58;" Then Variable=False
End Function 'Variable
  
Sub GetNextNonBlankChar(a$,p,b$)
  '&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;
  ' Returns b$ either empty indicating end of line or
  ' containing the next non-blank character.
  ' A comment (single quote or REM) also indicates end of line.
  ' Any text inside double quotes is skipped.
  ' On entry, p points to the next char to inspect in a$.
  ' On exit, P points to the next character after the one in b$.
  '&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;
  Do
    If p&gt;=Len(a$) Or Mid$(a$,p,1)="'" Or UCase$(Mid$(a$,p,3))="REM" Then
      b$=""
    Else
      b$=Mid$(a$,p,1)
      If b$=Chr$(34) Then
        Do                         ' skip over quoted text
          p=p+1
        Loop Until Mid$(a$,p,1)=Chr$(34) Or p = Len(a$)
      EndIf
      p=p+1
    EndIf
  Loop Until b$="" Or b$&lt;&gt;" "
End Sub 'GetNextNonBlankChar
  
Sub ExtractLineNo
  '&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;
  ' Saves the line number if present and pads it to
  ' the length of the longest one. If some of the code uses line
  ' numbers and some not, then those without line numbers are
  ' indented as if they had a line number.
  ' If the line number is followed by one or more spaces and
  ' a colon, the spaces between line number and colon are removed.
  '&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;
  Local j
  If Left$(Oline$,1)&gt;="0" And Left$(Oline$,1)&lt;="9" Then
    LineNo$=Left$(Oline$,Instr(1,Oline$," "))
    j=Len(LineNo$)
    GetNextNonBlankChar(Oline$,j,b$)
    If b$="&#58;" Then
      LineNo$=Left$(LineNo$,Len(LineNo$)-1)+"&#58; "
      Oline$=Mid$(Oline$,j)
    EndIf
    
    If Len(LineNo$) &lt; LineNoLen Then ' pad to longest line no
      LineNo$ = LineNo$ + Space$(LineNoLen-Len(LineNo$))
    EndIf
    Oline$=Right$(Oline$,Len(Oline$)-Instr(1,Oline$," "))
    Oline$=StripBlanks$(Oline$)
  Else
    LineNo$=Space$(LineNoLen)
  EndIf
End Sub 'ExtractLineNo
  
Sub AdjustIndent
  '&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;
  ' For each command that affects the indent,
  ' adjust both current (CLI) and next line indent (NLI).
  ' Repeat until comment or end-of-line reached to handle multi-statement lines.
  '&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;
  EOL=False
  ForNest=False         'Nest level of FOR/NEXT
  DoFound=False
  Do
    Found=False
    Test_LineEnd(Found,EOL)
    If Not Found Then Test_Sub_Fn(Found)
    If Not Found Then Test_Do(Found)
    If Not Found Then Test_Loop(Found)
    If Not Found Then Test_For(Found)
    If Not Found Then Test_Next(Found)
    If Not Found Then Test_If_Then(Found,MultiLine)
    If Not Found Then Test_ElseIf(Found,MultiLine)
    If Not Found Then Test_Else(Found,MultiLine)
    If Not Found Then Test_EndIf(Found)
    If Not Found Then Test_for_label(Found)
    ' Look for other statements in the line
    If Not EOL Then
      FlushToColon
      Cline$=Stripblanks$(Cline$)
      If Cline$="" Then EOL=True
    EndIf
  Loop Until EOL
End Sub 'AdjustIndent
  
Sub Test_LineEnd(Found,EOL)
  '&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;
  ' Test if finished processing this line
  '&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;
  If Len(CLine$)&lt;=1 Or Left$(Cline$,1)="'" Or Left$(UCase$(Cline$),4)="REM " Then
    Found=True
    EOL=True
  EndIf
End Sub 'Test_LineEnd
  
Sub FlushToColon
  '&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;
  ' Find the next statement on a multi-statement line
  '&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;
  Local i
  i=1
  Do
    GetNextNonBlankChar(Cline$,i,a$)
  Loop Until a$ = "&#58;" Or a$ = ""
  If a$="" Then
    Cline$=""      ' reached EOL
  Else
    Cline$=Right$(Cline$,Len(Cline$)-i+1)
  EndIf
End Sub 'FlushToColon
  
Sub Test_Sub_Fn(Found)
  '&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;
  ' SUB &amp; FUNCTION start &amp; end stmts are aligned to the left margin
  '&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;
  If UCase$(Left$(Cline$,4))="SUB " Then
    Found = True
  ElseIf UCase$(Left$(Cline$,7))="END SUB" Then
    Found = True
  ElseIf UCase$(Left$(Cline$,9))="FUNCTION " Then
    Found = True
  ElseIf UCase$(Left$(Cline$,12))="END FUNCTION" Then
    Found = True
  EndIf
  If Found Then
    NLI = CLI       'save current indent
    CLI = 0         'Move this line to the left margin
  EndIf
End Sub 'Test_Sub_Fn
  
Sub Test_Do(Found)
  '&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;
  'Print the DO at the current indent but indent the next line further
  '&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;
  If UCase$(Left$(Cline$,2))="DO" And Not Variable(Cline$,3) Then
    NLI = NLI + Indent
    DoFound=True
    Found = True
  EndIf
End Sub 'Test_Do
  
Sub Test_Loop(Found)
  '&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;
  'If LOOP, print this and the next line one less indent
  '&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;
  If UCase$(Left$(Cline$,4))="LOOP" And Not Variable(Cline$,5) Then
    If DoFound Then
      NLI=CLI
    Else
      CLI = CLI - Indent   'remove one level of indent
      NLI = CLI            'make the next line indent the same
    EndIf
    Found = True
  EndIf
End Sub 'Test_Loop
  
Sub Test_For(Found)
  '&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;
  'Print the FOR at the current indent but indent the next line one indent
  '&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;
  If UCase$(Left$(Cline$,3))="FOR" And Not Variable(Cline$,4) Then
    NLI = NLI + Indent
    ForNest=ForNest+1
    Found = True
  EndIf
End Sub 'Test_For
  
Sub Test_Next(Found)
  '&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;
  'If NEXT, print this and the next line one less indent
  '&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;
  If UCase$(Left$(Cline$,4))="NEXT" And Not Variable(Cline$,5) Then
    If ForNest Then
      NLI = CLI
      ForNest=ForNest-1
    Else
      CLI = CLI - Indent   'remove one level of indent
      NLI = CLI            'make the next line indent the same
    EndIf
    Ptr = 5
    ' Look for a comma which closes multiple For levels
    Do
      GetNextNonBlankChar(Cline$,Ptr,a$)
      If a$ = "," Then
        If ForNest Then
          ForNest=ForNest-1
        Else
          CLI = CLI - Indent  'remove another level of indent
          NLI = CLI           'make the next line indent the same
        EndIf
      EndIf
    Loop Until a$ = "" Or a$ = "&#58;" ' Both end the NEXT statement
    Found=True
  EndIf
End Sub 'Test_Next
  
Sub Test_If_Then(Found,ML)
  '&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;
  'Print the IF/ELSE at the current indent but indent the next line further
  '&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;
  If UCase$(Left$(Cline$,3))="IF " Then
    ' test for one-line IF/THEN.
    ' "Then" will be followed by a non-blank character
    Ptr = Instr(4,UCase$(Cline$)," THEN")
    Ptr=Ptr+6
    GetNextNonBlankChar(Cline$, Ptr, b$)
    ' if statement continues on next line, indent the next line
    If b$="" Or b$=" " Then
      NLI = CLI + Indent
      ML=1              'Indicate a multi-line IF
    EndIf
    Found=True
  EndIf
End Sub 'Test_If_Then
  
Sub Test_ElseIf(Found,ML)
  '&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;
  ' If on entry, MultiLn=1, the previous THEN/ELSE was a multiline statement
  '&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;
  If UCase$(Left$(Cline$,6))="ELSEIF" And Not Variable(Cline$,7) Then
    If ML = 1 Then CLI = CLI - Indent
    ML=0
    ' test for one-line ELSEIF/THEN.
    ' The ELSE will be followed by a non-blank character
    Ptr = Instr(4,UCase$(Cline$)," THEN")
    Ptr=Ptr+6
    GetNextNonBlankChar(Cline$, Ptr, b$)
    If b$="" Or b$&lt;&gt;" " Then
      NLI = CLI + Indent
      ML=1
    EndIf
    Found=True
  EndIf
End Sub 'Test_ElseIf
  
Sub Test_Else(Found,ML)
  '&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;
  ' If on entry, MultiLn=1, the previous THEN/ELSE was a multiline statement
  '&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;
  If UCase$(Left$(Cline$,4))="ELSE" And Not Variable(Cline$,5) Then
    If ML = 1 Then CLI = CLI - Indent
    ML=0
    ' test for one-line ELSE/THEN.
    ' The ELSE will be followed by a non-blank character
    Ptr = Instr(4,UCase$(Cline$)," THEN")
    Ptr=Ptr+6
    GetNextNonBlankChar(Cline$, Ptr, b$)
    If b$="" Or b$&lt;&gt;" " Then
      NLI = CLI + Indent
      ML=1
    EndIf
    Found=True
  EndIf
End Sub 'Test_Else
  
Sub Test_EndIf(Found)
  '&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;
  'If ENDIF, print this and the next line one less indent
  '&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;
  If UCase$(Left$(Cline$,5))="ENDIF" And Not Variable(Cline$,6) Then
    CLI = CLI - Indent   'remove one level of indent
    NLI = CLI            'make the next line indent the same
    Found=True
  EndIf
End Sub 'Test_EndIf
  
Sub Test_for_Label(Found)
  '&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;
  ' A line starting with a label is aligned to the left margin
  ' A label is terminated with a colon and musn't
  ' - have an imbedded blank or operator.
  ' - be an MMBasic command terminated with a colon.
  '&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;
  Found=False
  p=Instr(1,Cline$,"&#58;")                       ' Look for first colon
  If p&lt;&gt;0 Then
    Found=True       'Provided there is no imbedded blank or operator
    For i=1 To p-1
      a$=Mid$(Cline$,i,1)
      If a$=" " Or IsOperator(a$) Then
        Found=False
        Exit For
      EndIf
    Next
  EndIf
  ' Check that it is not a one word MMBasic command
  If found And p&lt;&gt;0 Then
    For i=1 To Commands
      If UCase$(Left$(Cline$,p-1))=Command$(i) Then
        Found=False
        Exit For
      EndIf
    Next
  EndIf
  If Found=True Then
    CLI=0
  EndIf
End Sub 'Test_for_Label
  
Function IsOperator(a$)
  '&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;
  ' Tests a$ to see if it is an operator
  '&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;
  Local i
  IsOperator=False
  For i=1 To Operators
    If a$=Operator$(i) Then
      IsOperator=True
      Exit For
    EndIf
  Next
End Function 'IsOperator
  
Sub Initialise(Ifile$,Ofile$,Indent)
  '&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;
  ' Input and Output file names, indent and pause switch can come from
  ' 4 sources (in order of precedence&#58;
  '  - MM.CMDLine$, the implied RUN command
  '  - CMDParm$, a variable passed by a program that chains to Format.
  '  - FORMAT.DAT file in the same format as MM.CMDline$
  '  - User prompts
  ' If file names are missing from the first 2, the user is prompted to
  ' enter them. If indent and pause switch are omitted, defaults are used.
  '&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;
  a$=MM.CmdLine$
  If a$&lt;&gt;"" Then
    Print "Getting parms from MM.CMDLine$."
    GetCMDLine(a$)
  ElseIf CMDParm$&lt;&gt;"" Then
    ' CMDParm$ is intended to be passed by a Chaining program
    Print "Getting parms from CMDParm$."
    GetCMDLine(CMDParm$)
  Else
    a$=GetParmsFromFile$(CMDParmFile$)
    If MM.Errno=0 Then Print "Getting parms from file ";CMDParmFile$
    If a$&lt;&gt;"" Then GetCMDLine(a$)
  EndIf
  Do
    If Ifile$="" Then
      Input "Give me the Input  filename (.BAS assumed) - 'Exit' to exit&#58; ", Ifile$
    EndIf
    If LCase$(Ifile$)="exit" Then End
    CheckInputFileName(Ifile$)
  Loop Until Ifile$&lt;&gt;""
  Do
    If Ofile$="" Then
      Input "Give me the Output filename (.BAS assumed) - 'Exit' to exit&#58; ", Ofile$$
    EndIf
    If LCase$(Ofile$)="exit" Then End
    CheckOutputFilename(Ofile$, Ifile$)
  Loop Until Ofile$&lt;&gt;""
  If Indent = 0 Then
    GetIndent(Indent)
    If Indent=0 Then End
  EndIf
  If PauseList$="" Then GetPause(PauseList$)
End Sub 'Initialise
  
Function GetParmsFromFile$(DATFile$)
  '&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;
  'Gets the parameters from a file provided by Renumber
  '&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;
  Local a$
  Option error continue
  Open DATFile$ For input As &#35;3
  If MM.Errno = 0 Then
    Line Input &#35;3,a$
    GetParmsFromFile$=a$
    Close &#35;3
  EndIf
  Option error abort
End Function 'GetParmsFromFile
  
Sub GetCMDLine(a$)
  '&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;
  ' MMBasic 4.3A onward which supports implied Run command
  ' User can start the program with FORMAT infilename outfilename &#91;Indent&#93; &#91;/p&#93;
  ' /p lists the output a screenful at a time. Press any key to continue.
  ' On exit Parm$(1) = infilename, Parm$(2) = outfilename, Parm3 = Indent 0r 0
  '&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;
  Local i
  If a$&lt;&gt;"" Then
    ParmNo=5                 ' Examine up to 5 parms
    ' Set the delimiter between parms
    If Instr(1,a$,",") Then ParmDelimiter$="," Else ParmDelimiter$=" "
    Dim Parm$(ParmNo)
    ParseParm(a$,ParmNo,ParmDelimiter$)
    Ifile$=Parm$(1)
    Ofile$=Parm$(2)
    Indent=2
    PauseList$="N"
    For i=3 To ParmNo
      If Val(Parm$(i)) &gt; 0 Then Indent=Val(Parm$(3))
      If UCase$(Parm$(i))="/P" Then PauseList$="Y"
    Next
  EndIf
  Erase Parm$               'Not needed any more - save the space
End Sub 'GetCMDLine
  
Sub ParseParm(p$,PNo,Delim$)
  '&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;
  ' Parse the parameters on the Implied Run Command line,
  ' from CMDparm$ or the DAT file.
  '&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;
  Local i,Strt,Ptr
  Strt=1
  For i=1 To PNo
    Ptr=Instr(Strt,p$,Delim$)
    If Ptr=0 Then Ptr=Len(p$)+1
    Parm$(i)=Mid$(p$,Strt,Ptr-Strt)
    If Ptr&gt;=Len(p$) Then Exit For
    Strt=Ptr
    FindNextParmDelimiter(p$,Strt,Delim$)
  Next
  If UCase$(Parm$(3))="/P" Then   ' user opted to omit Indent so
    Parm$(4)=Parm$(3)           ' shift pause list parm to it's proper place
    Parm$(3)=""                ' and clear the Indent parm
  EndIf
End Sub 'ParseParm
  
Sub FindNextParmDelimiter(a$,p,Delim$)
  '&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;
  ' Fine the start of the next parameter
  '&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;
  Do
    p=p+1
  Loop Until Mid$(a$,p,1)&lt;&gt;Delim$ Or p=Len(a$)
End Sub 'FindNextParmDelimiter
  
Sub CheckInputFilename(i$)
  '&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;
  ' Adds .BAS if an extension is not provided and checks that is accessible
  '&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;
  If Instr(1,i$,".")=0 Then i$=i$+".bas"
  Option error continue
  Open i$ For INPUT As &#35;1
  If MM.Errno &lt;&gt; 0 Then
    Print i$ " doesn't exist."
    Print
    i$=""
  EndIf
  Option error abort
End Sub 'CheckInputFilename
  
Sub CheckOutputFileName(o$,i$)
  '&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;
  ' Adds .BAS if an extension is not provided and checks that it does't alread exit.
  ' If it exists, asks user if ok to overwrite.
  '&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;
  If Instr(1, o$, ".") = 0 Then o$ = o$ + ".bas"
  If LCase$(o$)=LCase$(i$) Then
    Print "You cannot write to the input file - give me another."
    Print
    o$=""
  Else
    ' If old file exists, ask if it should be replaced. If not, get another filename
    Option error continue
    Open o$ For input As &#35;2
    If MM.Errno = 0 Then
      Print "OK to overwrite "+o$+" Y/N";&#58;Input ""; Reply$
      If LCase$(Left$(Reply$,1)) = "y" Then
        Close &#35;2
        Open o$ For output As &#35;2
      Else
        Close &#35;2
        Print
        o$=""
      EndIf
    Else
      Open o$ For output As &#35;2
    EndIf
    Option error abort
  EndIf
End Sub 'CheckOutputFileName
  
Sub GetIndent(i)
  '&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;
  ' Asks user for number of spaces to use for each level of indent
  '&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;
  Do
    Input "What indent should I use? (Range 1-6, 0 to exit)&#58; ", i
    If i&lt;0 Or i&gt;6 Then
      Print "Indent needs to be in the range 1 to 6, or type 0 to exit"
      Print
    EndIf
  Loop Until i&gt;=0 And i&lt;=6
End Sub 'GetIndent
  
Sub GetPause(a$)
  '&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;
  ' Asks user if screen listing should be paused at end of each screenful.
  '&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;
  Do
    Input "Pause the listing at the end of each screenful (y/n)?", a$
    a$ = UCase$(a$)
    If a$ &lt;&gt; "Y" And a$ &lt;&gt; "N" Then
      Print "Please answer Y or N."
      Print
    EndIf
  Loop Until a$ = "Y" Or a$ = "N"
End Sub 'GetPause
  
Sub PrintInstructions
  '&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;
  Print @(MM.HRes/2-12&#42;10,1) "Program Source Formatter v2.0"
  Print @(MM.HRes/2-12&#42;10,12) "&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;"
  Print "This program reads a basic program file and creates a new one following"
  Print "these indent rules&#58;"
  Print " - Lines starting with a Label are aligned to the left margin"
  Print "   as are SUB, END SUB, FUNCTION and END FUNCTION."
  Print " - The first non-label line is indented to the first level."
  Print " - Lines following a single line IF, DO and FOR are not further indented."
  Print " - Multiline DO and FOR have their respective LOOP and NEXT aligned."
  Print "   Intervening lines are indented one level."
  Print " - Multiline IF statements have their ELSE, ELSEIF and ENDIF aligned"
  Print "   under the relevant IF. Intervening statements are indented one level."
  Print " - Nesting increases the indent one level."
  Print " - For numbered programs, the left margin is the longest number plus one."
  Print " - Other than setting the indent, the source line is not altered."
  Print " - No attempt is made to check the program for errors."
  Print
  Print "From MMBasic V4.3a you can invoke FORMAT from the Basic prompt using"
  Print "the implied RUN command. The syntax is&#58;"
  Print
  Print "   FORMAT InFileName&#91;.BAS&#93; OutFileName&#91;.BAS&#93; &#91;Indent&#93; &#91;/p&#93;"
  Print
  Print "Where&#58;   InFileName must not be the same as OutFileName"
  Print "         Indent defaults to 2 and"
  Print "         switch /p pauses the listing at a screenful."
  Print
End Sub 'PrintInstructions
  
Sub CheckForLineNumbers
  '&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;
  ' Check for line numbers and find the longest number
  ' Length of longest number + 1 will be used as the left margin
  '&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;
  Local i
  LineNumbers=False
  Do
    Line Input &#35;1, Iline$
    ILine$=StripBlanks$(ILine$)  'Remove any leading blanks
    If Left$(ILine$,1)&gt;="0" And Left$(ILine$,1)&lt;="9" Then
      LineNumbers=True
      i=Instr(1,ILine$," ")
      If i&gt;LineNoLen Then LineNoLen=i
    EndIf
  Loop Until Eof(&#35;1)
  Close &#35;1
  Open Ifile$ For Input As &#35;1
End Sub 'CheckForLineNumbers
  
Sub wait
  '&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;
  ' Causes the program to pause at the end of each screenful.
  ' Any keystroke causes the program to continue.
  '&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;&#42;
  w=w+1
  If w&gt;30 Then
    w=0
    Do
      k$=Inkey$
    Loop Until k$&lt;&gt;""
  EndIf
End Sub 'Wait
  
</pre><br />
	</div>
	
	
	
	<div id="PageAttachmentsDiv" style="position: absolute; left: 10000px;">
		
    </div>
    
    <div id="AdminToolsDiv" style="position: absolute; left: 10000px;">
		
		
		
    </div>
    
    <script type="text/javascript">
    <!--
    	function __RepositionDiv(link, element) {
    		var absPos = __AbsolutePosition(link);
    		var elemAbsPos = __AbsolutePosition(element);

    		element.style["top"] = (absPos.top + absPos.height) + "px";
    		element.style["left"] = (absPos.left - (elemAbsPos.width - absPos.width)) + "px";
    		element.style["position"] = "absolute";
    	}

		// Hide attachments and admin tools divs
    	// This is needed because __RepositionDiv cannot calculate the width of the element when it's hidden
    	var __elem = document.getElementById("PageAttachmentsDiv");
    	if(document.getElementById("PageAttachmentsLink")) {
    		__RepositionDiv(document.getElementById("PageAttachmentsLink"), __elem);
    	}
    	__elem.style["display"] = "none";

    	__elem = document.getElementById("AdminToolsDiv");
    	if(document.getElementById("AdminToolsLink")) {
    		__RepositionDiv(document.getElementById("AdminToolsLink"), __elem);
    	}
    	__elem.style["display"] = "none";

    	__InitBCT();
    // -->
    </script>


                <div id="PageInternalFooterDiv"></div>
                <div id="MainFooterDiv">
                    <!-- Used for layout purposes only -->
                </div>
            </div>

        </div>
            
        <div id="FooterDiv">
             
        </div>

    </form>  
</body>

<!-- Mirrored from fruitoftheshed.com/MMBasic.MMBasic-Source-Code-Formatter-part-of-the-original-MMBasic-library.ashx?NS=MMBasic by HTTrack Website Copier/3.x [XR&CO'2014], Wed, 09 Feb 2022 12:51:09 GMT -->
</html>
